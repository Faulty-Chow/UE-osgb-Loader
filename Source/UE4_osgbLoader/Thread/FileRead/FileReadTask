#pragma once
#include "../../UE4_osgbLoader.h"
#include "../BaseAsyncTask"
#include "CoreMinimal.h"

#include <osg/Node>

#include <string>
#include <functional> 

#ifdef _LOG_BaseAsyncTask
#if _LOG_BaseAsyncTask
#define _LOG_FileReadTask 1
#else
#define _LOG_FileReadTask 0
#endif
#else
#define _LOG_FileReadTask 0
#endif

class BaseThreadPool;

class SaveResultFunctor
{
public:
	void operator()(osg::Node*)
	{

	}
};

//class FileReadTask :public BaseAsyncTask
//{
//public:
//	typedef std::function<void(osg::Node*)> SaveResultFunction;
//	FileReadTask(std::string filePath, BaseThreadPool* dataManageThreadPool, SaveResultFunction& saveResultFunction) :
//		_bAbandon(false), _filePath(filePath), _dataManageThreadPool(dataManageThreadPool), _saveResultFunction(saveResultFunction)
//	{
//	}
//	~FileReadTask() = default;
//	virtual void Abandon() override 
//	{
//#if _LOG_FileReadTask
//		UE_LOG(LogTemp, Error, TEXT("File Read: %s, is Abandoned."), *FString(_filePath.c_str()));
//#endif
//		_bAbandon.exchange(true);
//	}
//	virtual int32 Execute() override;
//	virtual void SaveResult() override
//	{
//		_saveResultFunction(_readResult);
//	}
//private:
//	std::atomic_bool _bAbandon;
//	std::string& _filePath;
//	osg::Node* _readResult;
//	BaseThreadPool* _dataManageThreadPool;
//	// void (*Func_FileReadResponse)(osg::Node*);
//	SaveResultFunction& _saveResultFunction;
//};